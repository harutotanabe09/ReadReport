＃読書レポート

## 失敗から学ぶRDBの正しいあるき方

### ＊　読んだきっかけ

・DBの設計について書かれている本がすくない。どういったテーブル構成に悩んで行き着いた。

　今の社内システムのDBが特にひどいので、テーブルを再定義するのに役に立つ。

### ＊　本の内容

・アンチパターンの設計をしないためにどういった対応が必要か、またアンチパターンでの実装済みのテーブルをどう修正するか、現場のあるある事例を元に具体的な対応が書かれている

### ＊　学び

#### パターン１）項目名と実際に入っている項目が合わない。

　例）　削除フラグに０，１以外にも２や３といった値が入っている。

　→　対策①型をBooleanにする②新しい項目を作成してトリガーで値をセット、問題なければ元の項目削除

#### パターン２）履歴テーブルを持たないと過去の状態がわからない

　例）　消費税が8%という値をもっていたため、10％上げるとすべて10％になった

　→　対策①期間という軸をもたせる。ただし、過去（履歴テーブル）を残すとデータが肥大化する。

　　　対策②遅延したレプリケーションをもたせる

#### パターン３）むやみにJOINしているテーブル

　例）　５つや６つのテーブルをJOINしている。JOINの内部表にINDEXがないためパフォーマンスも遅い

　→　対策①　JOINする前にサブクエリで絞り込んでJOINする

#### パターン４）効かないIndex

　例）名前を後方一致で検索など

　→　対策①　20％未満に絞れる項目が1つの目安

　　　対策②　テーブルのデータが多いのが条件。マスタ系だとデータ量すくないのでつけても無駄なケースも。

　　　対策③　関数を使わない　 age / 10 < 10 など式を使うと遅い

#### パターン５）フラグの闇

　例）削除フラグを持つことで、１つのIDで削除フラグ１と０ができてしまう

　→　対策①　項目ではなくテーブルでデータを持つ[削除済みテーブル]にデータを移す。トリガー使う。

#### パターン６）ソートの依存

　例）ORDER BYを使っているが、過去ページになると表示が遅い

　→　対策①　ORDER BYにINDEX項目を使う？？★要調査。

　　　対策②　ID項目を使う

　　　対策③　キャッシュ（Redis)を使う。Sorted Setは早い。ただ、永続データが苦手。

#### パターン７）隠された状態

　例）社員番号が９の番号を管理者と★アプリ★側で制御している

　→　対策①　事実のみをDBに登録する。テーブルのサブテーブルに権限を追加して状態をもたせる

#### パターン８）JSONの甘い罠

　例）項目にJSON型をつかっている。必須項目の制御などがかけれない

　→　対策①）　WebAPIの戻り値、ほとんどアップデートしない項目、プラグイン

#### パターン９）強すぎる成約

　例）メールドアレス型があり、固有な制約で制御されている。外部キー制約。

　→　対策①）アプリ側で規約をもたせる

　　　対策②）遅延制約（Postgres固有０

#### パターン１０）ころんだあとのバックアップ

　→　対策①）論理バックアップ（ダンプ　：テキストファイル、バックアップ速度早い

　　　対策②）物理バックアップ　：バックアップ遅い、互換性ない場合ある

　　　対策③）PITR ：特定の時間のバックアップ

　　　※　バックアップとリストアの自動化。本番のデータをステージングに定期的にバックアップする。

#### パターン１１）見えないログ

　例）エラーログの場所を知らない、見方をしらない

　　　対策①）それぞれのDBのエラーログ見える場所確認する（Posgres,Logging）

　　　対策②）監視するシステム　Slack通知、Zabbix、Makerarel、Elastic Stack

#### パターン１２）監視されていないDB

　例）サービス停止

　　　具体例：死活監視、チェック監視、メトリックス監視

　　　★　Zabbix、マカレル、DataDog

　　　他にも　MySqlならPMP　Postgresならpg_monz , pg_stats_reporter

#### パターン１３）知らないロック

　例）SELECT文が返ってこない。デッドロックしている。

　　　具体例）排他表ロック

　　　対策：ロックを小さくする　PostgresならAccessShareLockにする。MySQLなら

#### パターン１４）ロックの功罪

　例）データの不整合。トランザクションレベルが正しくない。ダーティーリード・フィジーリード・ロストアップデート発生。

　　　対策：RepeatableReadを使う

#### パターン１４）簡単すぎる不整合

　例）非正規化していたため、データ参照が大変？

#### パターン１５）キャッシュ中毒

　例）キャッシュを多用している

　対策：キャッシュの有効期限や目的を理解して使用する

#### パターン１６）複雑なクエリ

　例）上のJOIN多様なようにCASE WHENなどを多用している

#### パターン１７）ノーチェンジ・コンフィグ

　例）MySQLやPostgresが初期設定のまま

　対策：Ansibleなどでインフラをコード化する。

　　　　コンフィグチェックツールを使う。PgtuneやMYSQLTunerなどのツール。

#### パターン１８）塩漬けのバージョン管理

　例）MySQLやPostgresのバージョンがそのまま

　対策：バージョンアップする。

　　　　バージョンアップ時はダンプの取得はレプリケーションの切り替えなどを考慮する必要あり

